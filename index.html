<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<title>particles</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js" type="text/javascript"></script>

	<style type="text/css">
		body, canvas {
			background-color: #000;
			margin:0;
			padding:0;
			}
		#start, #reset {
			position: absolute;
			top: 20px;
			left: 30px;
			z-index:1;
			}
		#fire {
			position: absolute;
			top: 0px;
			left: 0px;
			}
	</style>
</head>
	
<body>
	<script type="text/javascript">
	
	// shim layer with setTimeout fallback
	window.requestAnimFrame = (function(){
		return window.requestAnimationFrame	|| 
			window.webkitRequestAnimationFrame	|| 
			window.mozRequestAnimationFrame		|| 
			window.oRequestAnimationFrame		|| 
			window.msRequestAnimationFrame		|| 
			function(callback){
				window.setTimeout(callback, 1000 / 60);
				};
		})();
	
		
		function emitter(options){
			var defaults = {
				x: 0,
				y: 0,
				max_particles: 200,
				per_second: 20,
				life: 1,
				type: 'point',
				radius: 15,
				w: 20,
				h: 20,
				
				f_step: function(p){
					p.y += 1;
					return true
					},
				
				f_render: function(p){
					this.beginPath();
					this.arc(p.x, p.y, 3, 0, 2 * Math.PI);
					this.fill();
					},
					
				};
			
			// Random rectangular coordinates
			function rect(w, h){
				return {x: w * Math.random(), y: h * Math.random()};
				}
			
			// non uniform distrobution of random coordinates
			function circle(radius){
				var theta = Math.random() * Math.PI * 2;
				var length = Math.random() * radius;
				
				return {x: Math.cos(theta) * length, y: Math.sin(theta) * length};
				}
			
			// Uniformly random coordinate inside circle
			function ucircle(radius){
				var r = radius * Math.sqrt(Math.random());
				var theta = 2 * Math.PI * Math.random();
				
				return {x: r * Math.cos(theta), y: r * Math.sin(theta)};
				}
			
			
			var e = $.extend({}, defaults, options);
			this.particles = [];
			var num_p = 0; // number of particles in the scene
			var frame = 1;
			var ppf = e.per_second / 60; // penguins per frame
			var pets = 0; // penguins emitted this second
			this.x = e.x;
			this.y = e.y;

			
			this.particle = function(){
				this.x = 0;
				this.y = 0;
				//this.xi = 0; // x direction
				//this.yi = 0; // y direction
				//this.xg = 0; // x gravity
				//this.yg = 0; // y gravity
				this.size = 7;
				this.scale = 1.0;
				this.life = e.life * (Math.random() + 1) * 1000;
				this.created = new Date().getTime();
				this.seed = (Math.random() - 0.5) * 0.8;
				};
				
			
			
			var get_pos;
			if (e.type == 'rect'){
				get_pos = function(){return rect(e.w, e.h)};
			} else if (e.type == 'circle') {
				get_pos = function(){return circle(e.radius)};
			} else if (e.type == 'ucircle') {
				get_pos = function(){return ucircle(e.radius)};
			} else if (typeof(e.type) == 'function') {
				get_pos = e.type;
			} else {
				get_pos = function(){return {x: 0, y: 0}};
				}
				
				
			
			
			this.translate = function(nx, ny){
				this.x = nx || this.x;
				this.y = ny || this.y;
				};
			
			
			this.generate = function(){
				
				this.particles = this.particles.filter(e.f_step);
				num_p = this.particles.length;
				
				if(num_p >= e.max_particles) return 0;
				
				// calculate total particles that should have been emitted by now
				var new_pets = frame * ppf
				var pte = Math.floor(new_pets - Math.floor(pets)); // particles to emit (this frame)
				
				
				// emit
				for(var i = 0; i < pte; i++){
					var p = new this.particle();
					var pos = get_pos();
					p.x = pos.x+this.x;
					p.y = pos.y+this.y;
					this.particles.push(p);
					}
				
				// save the number of particles emitted so far for the next go around
				pets = new_pets;
				
				if (frame >= 60) {
					frame = 1;
					pets = 0;
				} else {
					frame++;
					}
				
				return pte; // particles emitted this frame
				};
				
				
			this.render = function(ctx){
				ctx.save();
				
				//ctx.translate(this.x, this.y);
				
				this.particles.map(e.f_render, ctx);
				
				ctx.restore();
				};
				
			
			}
			
			
		function fire_step(p){
			var ms = new Date().getTime();
			
			if(ms >= p.created + p.life){
				return false;
				}
			
			p.scale = 1 - ((ms - p.created) / p.life);
			
			p.y += 3;
			
			//p.x = Math.sin((p.y / Math.PI) * (p.seed)) * 10;
			
			// jitter
			p.x += Math.random()*4-2;
			
			return true;
			}
			
			
		function fire_particle(p){
			this.save();
			this.globalCompositeOperation = "lighter";
			this.beginPath();
			
			this.arc(p.x, p.y, p.size * p.scale, 0, 2 * Math.PI);
			
			this.fillStyle = "#FFAD33";
			//this.fillStyle = "rgba(255, 173, 51, "+ (p.scale * 0.5 + 0.5) +")";
			
			this.fill();
			this.restore();
			}
			
		
		function draw(canvas){
			var c = $(canvas);
			var ctx = c[0].getContext("2d");
			
			var w = ctx.canvas.width;
			var h = ctx.canvas.height;
			
			
			ctx.clearRect(0, 0, w, h);
			
			ctx.save();
			
			// flip canvas upside down
			ctx.scale(1, -1);
			ctx.translate(0, -h);
			
			emitters.map(function(e){
				e.generate();
				e.render(ctx);
				});
			
			ctx.restore();
			
			}
		
		
		
		function frame(){
			requestAnimFrame(frame);
			draw('#fire');
			//setTimeout(frame, 16.6);
			}
		
		
		
		var emitters = [];
		function reset(){
		
			$('#start, #reset').toggle();
			emitters = [];
			
			}
		function start(){
		
			$('#start, #reset').toggle();
			
			emitters.push(
				new emitter({
							x: 50,
							y: 50,
							life: 0.5,
							per_second: 400,
							max_particles: 1000,
							f_step: fire_step,
							f_render: fire_particle,
							type: 'ucircle',
							//w: 30,
							//h: 10,
							radius: 10
							})
				);
			}
			
		$(function(){
			
			var w = $(window)
			
			w.resize(function(){
				$('#fire').attr({width: w.width(), height: w.height()});
				});
			w.trigger('resize');
			
			var mousedown = false;
			
			// mouse tracking for all emitters
			$('#fire').mousemove(function(event){
				//var c = this;
				
				if (!emitters.length) return;
				
				var e = emitters[0];
				e.x = event.pageX - this.offsetLeft;
				e.y = this.offsetHeight - (event.pageY - this.offsetTop);
				
				if (mousedown) {
					emitters.push(
						new emitter({
									x: e.x,
									y: e.y,
									life: 0.5,
									per_second: 2,
									max_particles: 100,
									f_step: fire_step,
									f_render: fire_particle//,
									//type: 'circle',
									//w: 30,
									//h: 10,
									//radius: 3
									})
						);
					}
				
				});
			
			$('#fire').mousedown(function(event){
				mousedown = true;
				});
			$('#fire').mouseup(function(event){
				mousedown = false;
				});
			
			// start frame loop
			frame();
			});
	</script>
	
	<button onclick="start();" id="start">start</button>
	<button onclick="reset();" style="display:none;" id="reset">reset</button>
	<canvas id="fire" width="250" height="250"></canvas>
	
	
	
	
	
</body>
</html>
